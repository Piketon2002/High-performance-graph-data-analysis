# Высокопроизводительный анализ графов

Знакомство с графовым представлением данных, решение некоторых полезных с практической точки зрения задач. Ниже представлены подробные их описания:

##  1. Реализация подсчёта треугольников несколькими алгоритмами (наивный, наивный с маской, Cohen's, Sandia) с помощью `python-graphblas` - см. `trianges.ipynb`

Что реализовано:

- [ ] Наивный алгоритм, для матрицы смежности $A$ вычисляющий $A^3$ и возвращающий количество треугольников неориентированного графа.
- [ ] Наивный алгоритм с маской, для матрицы смежности $A$ вычисляющий $A^2$ и возвращающий количество треугольников неориентированного графа.
- [ ] Сohen's algorithm, вычисляющий количество треугольников неориентированного графа.
- [ ] Sandia algorithm, вычисляющий количество треугольников неориентированного графа.

Также:

- [ ] Реализована функция, вычисляющая для каждой вершины неориентированного графа количество треугольников, в которых она участвует.
- [ ] Добавлены тесты для проверки корректности полученных реализаций.
- [ ] Оценено время работы всех полученных реализаций (сравнение алгоритмов) - для этого были взяты 10 графов в формате `Matrix Market` с сайта [SuiteSparse Matrix Collection](https://sparse.tamu.edu/) 
- [ ] Реализован генератор случайных неориентированных графов, в котором можно задавать количество вершин и степень разреженности графа. Путём генерации случайных графов различного размера и с разной степенью разреженности, в дополнение было оценено время работы всех полученных реализаций и исследованы границы их применимости.

Везде считалось, что вершины графа занумерованы подряд с нуля.


## 2. Реализация обхода в ширину из нескольких стартовых вершин (Multiple-Source BFS) с помощью `python-graphblas` - см. `MSBFS.ipynb`

Что реализовано:

- [ ] Функция обхода ориентированного графа (`MSBFS-Levels`) в ширину из нескольких заданных стартовых вершин.
  - [ ] Функция принимает представление графа, удобное для неё (загрузка, конвертация реализованы отдельно) и массив номеров стартовых вершин.
  - [ ] Функция возвращает массив пар: стартовая вершина, и массив (`levels`), где для каждой вершины указано, на каком уровне она достижима из этой стартовой. Стартовая вершина достижима на нулевом уровне, если вершина не достижима, то значение соответствующей ячейки сделайте равной -1.
- [ ] Функция обхода ориентированного графа (`MSBFS-Parents`) в ширину из нескольких заданных стартовых вершин.
  - [ ] Функция принимает представление графа, удобное для неё (загрузка, конвертация реализованы отдельно) и массив номеров стартовых вершин.
  - [ ] Функция возвращает массив пар: стартовая вершина, и массив (`parents`), где для каждой вершины графа указано, из какой вершины мы пришли в эту по кратчайшему пути из стартовой вершины. При этом для самой стартовой вершины такое значение взять равное -1, а для недостижимых вершин взять равное -2. При наличии нескольких возможных значений в массивах `parents` брать наименьшее.

Также:

- [ ] Добавлены тесты для проверки корректности полученных реализаций.
- [ ] Проведено экспериментальное исследование полученных реализаций на некоторых больших графах в формате `Matrix Market` с сайта [SuiteSparse Matrix Collection](https://sparse.tamu.edu/) и на случайных сгенерированных. Описана зависимость времени работы всех полученных реализаций от размеров графа, его степени разреженности, количестве стартовых вершин.
- [ ] Добавлены реализации описанных алгоритмов с использованием других полуколец (`any.pair` для `levels` и `any.first` для `parents`). Добавлены тесты для проверки корректности. Проведено экспериментальное исследование со сравнением этих реализаций с первоначальными на различных графах.

Везде считалось, что вершины графа занумерованы подряд с нуля.

## 3. Реализация поиска кратчайших путей с помощью `python-graphblas` (Bellman-Ford, Bellman-Ford Modified, Floyd–Warshall, Transitive Closure) - см. `shortest_paths.ipynb`

Что реализовано:

- [ ] Функция поиска кратчайших путей в ориентированном графе из заданной вершины (Bellman–Ford).
  - [ ] Функция принимает представление графа, удобное для неё (загрузка, конвертация реализованы отдельно) и номер стартовой вершины.
  - [ ] Функция возвращает массив, где для каждой вершины указано расстояние до неё от указанной стартовой вершины. Если вершина не достижима или кратчайшего пути для неё не существует, то значение соответствующей ячейки равно float('inf').
- [ ] Функция поиска кратчайших путей в ориентированном графе из нескольких заданных вершин, модифицировав предыдущий алгоритм.
  - [ ] Функция принимает представление графа, удобное для неё (загрузка, конвертация реализованы отдельно) и массив номеров стартовых вершин.
  - [ ] Функция возвращает массив пар: вершина, и массив, где для каждой вершины указано расстояние до неё из указанной. Если вершина не достижима или кратчайшего пути для неё не существует, то значение соответствующей ячейки равно float('inf').
- [ ] Две функции поиска кратчайших путей в ориентированном графе для всех пар вершин (Floyd–Warshall и вычисление транзитивного замыкания).
  - [ ] Функции принимают представление графа, удобное для неё (загрузка, конвертация реализованы отдельно).
  - [ ] Функции возвращают массив пар: вершина, и массив, где для каждой вершины указано расстояние до неё из указанной. Если вершина не достижима или кратчайшего пути для неё не существует, то значение соответствующей ячейки равно float('inf').

Также:

- [ ] Добавлены необходимые тесты.
- [ ] Проведено экспериментальное исследование полученных реализаций на некоторых больших графах в формате `Matrix Market` с сайта [SuiteSparse Matrix Collection](https://sparse.tamu.edu/) и на случайных сгенерированных. Описана зависимость времени работы всех полученных реализаций от размеров графа, его степени разреженности, количестве стартовых вершин. В частности выяснено, начиная с какой доли вершин в графе целесообразнее использовать алгоритм поиска кратчайших путей для всех пар вершин вместо того, чтобы решать задачу поиска кратчайших путей из нескольких стартовых (модифицированный Bellman-Ford).
- [ ] Оценен эффект от использования `push/pull direction optimization` для векторно-матричных операциях в алгоритмах. Опробованы разные стратегии (всегда push, всегда pull, с использованием порога наполненности вектора и т.д.).

Везде считалось, что вершины графа занумерованы подряд с нуля. 
